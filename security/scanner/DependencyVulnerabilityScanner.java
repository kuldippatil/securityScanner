//package com.security.scanner;
//
//import org.apache.commons.csv.CSVFormat;
//import org.apache.commons.csv.CSVPrinter;
//import org.apache.commons.lang3.ObjectUtils;
//import org.apache.commons.lang3.StringUtils;
//import org.apache.http.client.methods.CloseableHttpResponse;
//import org.apache.http.client.methods.HttpGet;
//import org.apache.http.impl.client.CloseableHttpClient;
//import org.apache.http.impl.client.HttpClients;
//import org.apache.http.util.EntityUtils;
//import org.json.JSONArray;
//import org.json.JSONObject;
//import org.owasp.dependencycheck.Engine;
//import org.owasp.dependencycheck.data.nvdcve.DatabaseException;
//import org.owasp.dependencycheck.dependency.Dependency;
//import org.owasp.dependencycheck.dependency.Vulnerability;
//import org.owasp.dependencycheck.exception.ExceptionCollection;
//import org.owasp.dependencycheck.utils.Settings;
//import org.apache.poi.ss.usermodel.*;
//import org.apache.poi.xssf.usermodel.XSSFWorkbook;
//import org.apache.poi.xssf.usermodel.XSSFSheet;
//import org.apache.poi.xssf.usermodel.XSSFFont;
//import org.apache.poi.common.usermodel.HyperlinkType;
//import com.google.api.client.auth.oauth2.Credential;
//import com.google.api.client.extensions.java6.auth.oauth2.AuthorizationCodeInstalledApp;
//import com.google.api.client.extensions.jetty.auth.oauth2.LocalServerReceiver;
//import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
//import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
//import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
//import com.google.api.client.http.FileContent;
//import com.google.api.client.json.gson.GsonFactory;
//import com.google.api.client.util.store.FileDataStoreFactory;
//import com.google.api.services.drive.Drive;
//import com.google.api.services.drive.DriveScopes;
//import com.google.api.services.drive.model.File;
//import com.google.api.services.drive.model.FileList;
//
//import java.io.File;
//import java.io.FileOutputStream;
//import java.io.FileWriter;
//import java.io.IOException;
//import java.net.URLEncoder;
//import java.nio.charset.StandardCharsets;
//import java.util.ArrayList;
//import java.util.List;
//import java.util.Collections;
//import java.io.InputStream;
//import java.io.FileNotFoundException;
//import java.io.InputStreamReader;
//import java.util.Map;
//import java.util.Set;
//import java.util.HashSet;
//import java.util.TreeMap;
//import java.util.stream.Collectors;
//
//public class DependencyVulnerabilityScanner {
//    private static final String[] CSV_HEADERS =
//        {"dependencyName", "packageName", "severity", "currentVersion", "latestVersion", "cve", "mvnLink"};
//
//    private static final String MAVEN_SEARCH_URL = "https://search.maven.org/solrsearch/select";
//    private static final String APPLICATION_NAME = "Dependency Vulnerability Scanner";
//    private static final String CREDENTIALS_FILE_PATH = "/credentials.json";
//    private static final String TOKENS_DIRECTORY_PATH = "tokens";
//    private static final List<String> SCOPES = Collections.singletonList(DriveScopes.DRIVE_FILE);
//    private static final String REPORT_MIME_TYPE = "text/csv";
//    private static final String EXCEL_MIME_TYPE = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
//    private String reportFileId = null; // To store the ID of the uploaded file
//    private final java.io.File previousScans = new java.io.File("previous_scans.json");
//
//    public void scan(String artifactPath, String outputPath) {
//        try (Engine engine = createEngine()) {
//            // Initialize the engine
//            engine.openDatabase();
//            System.out.println(" scan started : ");
//
//            // Scan the artifact
//            File artifactFile = new File(artifactPath);
//            engine.scan(artifactFile);
//            engine.analyzeDependencies();
//
//            // Generate report
//            List<VulnerabilityInfo> vulnerabilities = new ArrayList<>();
//            for (Dependency dependency : engine.getDependencies()) {
//                if (ObjectUtils.isNotEmpty(dependency) && StringUtils.isEmpty(dependency.getName())) {
//                    System.out.println("doing scan dependency name : " + dependency.getName());
//                }
//                if (dependency.getVulnerabilities() != null) {
//                    System.out.println(" dependency getting scan: ");
//                    String latestVersion = findLatestVersion(dependency);
//                    for (Vulnerability vulnerability : dependency.getVulnerabilities()) {
//                        vulnerabilities.add(new VulnerabilityInfo(dependency.getFileName(),
//                            dependency.getDisplayFileName() != null ? dependency.getDisplayFileName() : "Unknown",
//                            vulnerability.getCvssV3() != null ? vulnerability.getCvssV3().getBaseSeverity() : "UNKNOWN", latestVersion,
//                            vulnerability.getName(), getMavenLink(dependency)));
//                    }
//                }
//            }
//            System.out.println(" scan done for dependency proceeding to report generation : ");
//
//            // Generate reports
//            generateCSVReport(vulnerabilities, outputPath);
//            uploadToGoogleDrive(outputPath, REPORT_MIME_TYPE);
//
//            String excelPath = outputPath.replace(".csv", ".xlsx");
//            generateExcelReport(vulnerabilities, excelPath);
//            uploadToGoogleDrive(excelPath, EXCEL_MIME_TYPE);
//
//            // Generate additional reports
//            generateSecurityMetrics(vulnerabilities, outputPath);
//            generateRemedationPlan(vulnerabilities, outputPath);
//            generateDependencyGraph(vulnerabilities, outputPath);
//            generateTimelineReport(vulnerabilities, outputPath);
//
//            // Generate trend analysis
//            //            if (previousScans.exists()) {
//            //                generateTrendAnalysis(vulnerabilities, outputPath);
//            //            }
//
//            // Store current scan for future trend analysis
//            storeScanResults(vulnerabilities);
//
//        } catch (DatabaseException | ExceptionCollection | IOException e) {
//            throw new RuntimeException("Error during vulnerability scan", e);
//        }
//    }
//
//    private String findLatestVersion(Dependency dependency) {
//        try (CloseableHttpClient client = HttpClients.createDefault()) {
//            // Get dependency identifiers
//            String groupId = null;
//            String artifactId = null;
//
//            // Try to extract Maven coordinates from evidence
//            String identifier = dependency.getDisplayFileName();
//            String[] parts = identifier.split(":");
//            if (parts.length >= 2) {
//                groupId = parts[0];
//                artifactId = parts[1];
//            }
//
//            // If we couldn't find from evidence, try to parse from filename
//            if (groupId == null || artifactId == null) {
//                String fileName = dependency.getFileName();
//                System.out.println("Trying to find version for: " + fileName);
//
//                // Remove file extension and version
//                String baseName =
//                    cleanArtifactName(fileName.replaceAll("\\.(jar|war)$", "").replaceAll("-\\d+(\\.\\d+)*(-SNAPSHOT)?$", ""));
//
//                // Create search query using just the base name
//                String query = String.format("q=%s&rows=1&wt=json", URLEncoder.encode(baseName, StandardCharsets.UTF_8.toString()));
//
//                HttpGet request = new HttpGet(MAVEN_SEARCH_URL + "?" + query);
//                System.out.println("Search URL: " + MAVEN_SEARCH_URL + "?" + query);
//
//                try (CloseableHttpResponse response = client.execute(request)) {
//                    String jsonResponse = EntityUtils.toString(response.getEntity());
//                    System.out.println("Response: " + jsonResponse);
//                    JSONObject json = new JSONObject(jsonResponse);
//                    JSONObject responseObj = json.getJSONObject("response");
//
//                    if (responseObj.getInt("numFound") > 0) {
//                        JSONArray docs = responseObj.getJSONArray("docs");
//                        if (docs.length() > 0) {
//                            JSONObject firstDoc = docs.getJSONObject(0);
//                            String latestVersion = firstDoc.getString("latestVersion");
//                            System.out.println("Found latest version: " + latestVersion + " for " + baseName);
//                            return latestVersion;
//                        }
//                    }
//                }
//            } else {
//                // If we have groupId and artifactId, use them for more accurate search
//                String query =
//                    String.format("q=g:\"%s\" AND a:\"%s\"&rows=1&wt=json", URLEncoder.encode(groupId, StandardCharsets.UTF_8.toString()),
//                        URLEncoder.encode(artifactId, StandardCharsets.UTF_8.toString()));
//
//                HttpGet request = new HttpGet(MAVEN_SEARCH_URL + "?" + query);
//                System.out.println("Search URL: " + MAVEN_SEARCH_URL + "?" + query);
//
//                try (CloseableHttpResponse response = client.execute(request)) {
//                    String jsonResponse = EntityUtils.toString(response.getEntity());
//                    System.out.println("Response: " + jsonResponse);
//
//                    JSONObject json = new JSONObject(jsonResponse);
//                    JSONObject responseObj = json.getJSONObject("response");
//
//                    if (responseObj.getInt("numFound") > 0) {
//                        JSONArray docs = responseObj.getJSONArray("docs");
//                        if (docs.length() > 0) {
//                            JSONObject firstDoc = docs.getJSONObject(0);
//                            String latestVersion = firstDoc.getString("latestVersion");
//                            System.out.println("Found latest version: " + latestVersion + " for " + groupId + ":" + artifactId);
//                            return latestVersion;
//                        }
//                    }
//                }
//            }
//        } catch (Exception e) {
//            System.err.println("Error finding latest version for " + dependency.getFileName());
//            e.printStackTrace();
//        }
//        return "Unknown";
//    }
//
//    // Helper method to clean artifact names
//    private String cleanArtifactName(String name) {
//        // Remove common prefixes/suffixes
//        name = name.replaceAll("^(spring-|commons-|org\\.)", "").replaceAll("-core$", "").replaceAll("-java$", "");
//        return name;
//    }
//
//    private Engine createEngine() {
//        Settings settings = new Settings();
//        // Configure settings as needed
//        settings.setBoolean(Settings.KEYS.AUTO_UPDATE, true);
//        settings.setBoolean(Settings.KEYS.ANALYZER_CENTRAL_ENABLED, true);
//        return new Engine(settings);
//    }
//
//    private String getMavenLink(Dependency dependency) {
//        // This is a simplified version. You might want to implement proper Maven Central URL construction
//        return "https://mvnrepository.com/artifact/search?q=" + dependency.getFileName();
//    }
//
//    private void generateCSVReport(List<VulnerabilityInfo> vulnerabilities, String outputPath) throws IOException {
//        try (FileWriter writer = new FileWriter(outputPath);
//            CSVPrinter csvPrinter = new CSVPrinter(writer, CSVFormat.DEFAULT.withHeader(CSV_HEADERS))) {
//
//            for (VulnerabilityInfo vuln : vulnerabilities) {
//                csvPrinter.printRecord(vuln.dependencyName, vuln.packageName, vuln.severity, vuln.latestVersion, vuln.cve, vuln.mvnLink);
//            }
//        }
//        System.out.println(" file generated : ");
//    }
//
//    private void generateExcelReport(List<VulnerabilityInfo> vulnerabilities, String outputPath) throws IOException {
//        try (XSSFWorkbook workbook = new XSSFWorkbook()) {
//            XSSFSheet sheet = workbook.createSheet("Vulnerability Report");
//
//            // Create header row with style
//            Row headerRow = sheet.createRow(0);
//            CellStyle headerStyle = workbook.createCellStyle();
//            headerStyle.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
//            headerStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);
//            XSSFFont font = workbook.createFont();
//            font.setBold(true);
//            headerStyle.setFont(font);
//
//            // Create headers
//            for (int i = 0; i < CSV_HEADERS.length; i++) {
//                Cell cell = headerRow.createCell(i);
//                cell.setCellValue(CSV_HEADERS[i]);
//                cell.setCellStyle(headerStyle);
//            }
//
//            // Create data rows
//            int rowNum = 1;
//            CellStyle wrapStyle = workbook.createCellStyle();
//            wrapStyle.setWrapText(true);
//
//            for (VulnerabilityInfo vuln : vulnerabilities) {
//                Row row = sheet.createRow(rowNum++);
//                row.createCell(0).setCellValue(vuln.dependencyName);
//                row.createCell(1).setCellValue(vuln.packageName);
//                row.createCell(2).setCellValue(vuln.severity);
//                row.createCell(3).setCellValue(vuln.latestVersion);
//                row.createCell(4).setCellValue(vuln.cve);
//
//                // Create hyperlink for Maven URL
//                Cell urlCell = row.createCell(5);
//                Hyperlink link = workbook.getCreationHelper().createHyperlink(HyperlinkType.URL);
//                link.setAddress(vuln.mvnLink);
//                urlCell.setHyperlink(link);
//                urlCell.setCellValue(vuln.mvnLink);
//
//                // Set blue color and underline for URL
//                CellStyle hlinkStyle = workbook.createCellStyle();
//                XSSFFont hlinkFont = workbook.createFont();
//                hlinkFont.setUnderline(FontUnderline.SINGLE);
//                hlinkFont.setColor(IndexedColors.BLUE.getIndex());
//                hlinkStyle.setFont(hlinkFont);
//                urlCell.setCellStyle(hlinkStyle);
//            }
//
//            // Autosize columns
//            for (int i = 0; i < CSV_HEADERS.length; i++) {
//                sheet.autoSizeColumn(i);
//            }
//
//            // Write to file
//            String excelPath = outputPath.replace(".csv", ".xlsx");
//            try (FileOutputStream outputStream = new FileOutputStream(excelPath)) {
//                workbook.write(outputStream);
//            }
//            System.out.println("Excel report generated: " + excelPath);
//        }
//    }
//
//    private static class VulnerabilityInfo {
//        String dependencyName;
//        String packageName;
//        String severity;
//        String latestVersion;
//        String cve;
//        String mvnLink;
//        private String discoveryDate;
//        private String remedationStatus;
//        private List<String> affectedVersions;
//        private String fixedInVersion;
//        private double cvssScore;
//        private String attackVector;
//        private boolean exploitAvailable;
//        private String patchUrl;
//
//        public VulnerabilityInfo(String dependencyName, String packageName, String severity, String latestVersion, String cve,
//            String mvnLink) {
//            this.dependencyName = dependencyName;
//            this.packageName = packageName;
//            this.severity = severity;
//            this.latestVersion = latestVersion;
//            this.cve = cve;
//            this.mvnLink = mvnLink;
//        }
//    }
//
//    private Drive getDriveService() throws Exception {
//        Credential credentials = getCredentials();
//        return new Drive.Builder(GoogleNetHttpTransport.newTrustedTransport(), GsonFactory.getDefaultInstance(),
//            credentials).setApplicationName(APPLICATION_NAME).build();
//    }
//
//    private Credential getCredentials() throws Exception {
//        InputStream in = DependencyVulnerabilityScanner.class.getResourceAsStream(CREDENTIALS_FILE_PATH);
//        if (in == null) {
//            throw new FileNotFoundException("Resource not found: " + CREDENTIALS_FILE_PATH);
//        }
//
//        GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(GsonFactory.getDefaultInstance(), new InputStreamReader(in));
//
//        GoogleAuthorizationCodeFlow flow =
//            new GoogleAuthorizationCodeFlow.Builder(GoogleNetHttpTransport.newTrustedTransport(), GsonFactory.getDefaultInstance(),
//                clientSecrets, SCOPES).setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))
//                .setAccessType("offline").build();
//
//        LocalServerReceiver receiver = new LocalServerReceiver.Builder().setPort(8888).build();
//        return new AuthorizationCodeInstalledApp(flow, receiver).authorize("user");
//    }
//
//    private void uploadToGoogleDrive(String filePath, String mimeType) {
//        try {
//            Drive service = getDriveService();
//
//            // Create file metadata
//            File fileMetadata = new File();
//            fileMetadata.setName(new java.io.File(filePath).getName());
//
//            // Set file content
//            java.io.File fileContent = new java.io.File(filePath);
//            FileContent mediaContent = new FileContent(mimeType, fileContent);
//
//            if (reportFileId != null) {
//                // Update existing file
//                service.files().update(reportFileId, fileMetadata, mediaContent).execute();
//                System.out.println("File updated in Google Drive with ID: " + reportFileId);
//            } else {
//                // Upload new file
//                File file = service.files().create(fileMetadata, mediaContent).setFields("id").execute();
//                reportFileId = file.getId();
//                System.out.println("File uploaded to Google Drive with ID: " + reportFileId);
//            }
//        } catch (Exception e) {
//            System.err.println("Error uploading to Google Drive: " + e.getMessage());
//            e.printStackTrace();
//        }
//    }
//
//    private void generateSecurityMetrics(List<VulnerabilityInfo> vulnerabilities, String outputPath) throws IOException {
//        // Generate security score and metrics
//        int totalVulnerabilities = vulnerabilities.size();
//        int criticalCount = 0;
//        int highCount = 0;
//        int mediumCount = 0;
//        int lowCount = 0;
//
//        for (VulnerabilityInfo vuln : vulnerabilities) {
//            switch (vuln.severity.toUpperCase()) {
//                case "CRITICAL":
//                    criticalCount++;
//                    break;
//                case "HIGH":
//                    highCount++;
//                    break;
//                case "MEDIUM":
//                    mediumCount++;
//                    break;
//                case "LOW":
//                    lowCount++;
//                    break;
//            }
//        }
//
//        // Calculate security score (0-100)
//        double securityScore = 100 - ((criticalCount * 10) + (highCount * 5) + (mediumCount * 2) + (lowCount * 1));
//
//        // Generate metrics report
//        try (FileWriter writer = new FileWriter(outputPath.replace(".csv", "_metrics.txt"))) {
//            writer.write("Security Metrics Report\n");
//            writer.write("======================\n\n");
//            writer.write(String.format("Overall Security Score: %.2f/100\n\n", securityScore));
//            writer.write("Vulnerability Breakdown:\n");
//            writer.write(String.format("Critical: %d\n", criticalCount));
//            writer.write(String.format("High: %d\n", highCount));
//            writer.write(String.format("Medium: %d\n", mediumCount));
//            writer.write(String.format("Low: %d\n", lowCount));
//            writer.write(String.format("Total: %d\n", totalVulnerabilities));
//        }
//    }
//
//    private void generateRemedationPlan(List<VulnerabilityInfo> vulnerabilities, String outputPath) throws IOException {
//        try (FileWriter writer = new FileWriter(outputPath.replace(".csv", "_remediation.md"))) {
//            writer.write("# Vulnerability Remediation Plan\n\n");
//
//            // Group vulnerabilities by severity
//            Map<String, List<VulnerabilityInfo>> groupedVulns = vulnerabilities.stream().collect(Collectors.groupingBy(v -> v.severity));
//
//            // Critical vulnerabilities first
//            writer.write("## Critical Vulnerabilities - Immediate Action Required\n\n");
//            generateRemediationSection(writer, groupedVulns.get("CRITICAL"));
//
//            writer.write("## High Vulnerabilities - Action Required within 1 week\n\n");
//            generateRemediationSection(writer, groupedVulns.get("HIGH"));
//
//            writer.write("## Medium Vulnerabilities - Action Required within 1 month\n\n");
//            generateRemediationSection(writer, groupedVulns.get("MEDIUM"));
//
//            writer.write("## Low Vulnerabilities - Action Required within 3 months\n\n");
//            generateRemediationSection(writer, groupedVulns.get("LOW"));
//        }
//    }
//
//    private void generateRemediationSection(FileWriter writer, List<VulnerabilityInfo> vulns) throws IOException {
//        if (vulns == null || vulns.isEmpty()) {
//            writer.write("No vulnerabilities found in this category.\n\n");
//            return;
//        }
//
//        for (VulnerabilityInfo vuln : vulns) {
//            writer.write(String.format("### %s\n", vuln.cve));
//            writer.write(String.format("**Package**: %s\n", vuln.packageName));
//            writer.write(String.format("**Current Version**: %s\n", vuln.dependencyName));
//            writer.write(String.format("**Latest Version**: %s\n", vuln.latestVersion));
//            writer.write("\n**Remediation Steps**:\n");
//            writer.write("1. Update the dependency to the latest version\n");
//            writer.write(String.format("2. Check compatibility with version %s\n", vuln.latestVersion));
//            writer.write("3. Run regression tests after update\n\n");
//        }
//    }
//
//    private void generateDependencyGraph(List<VulnerabilityInfo> vulnerabilities, String outputPath) throws IOException {
//        // Generate a visual dependency graph using GraphViz
//        try (FileWriter writer = new FileWriter(outputPath.replace(".csv", "_graph.dot"))) {
//            writer.write("digraph DependencyGraph {\n");
//            writer.write("  node [shape=box];\n");
//
//            // Add nodes for each dependency
//            Set<String> processedDeps = new HashSet<>();
//            for (VulnerabilityInfo vuln : vulnerabilities) {
//                if (!processedDeps.contains(vuln.packageName)) {
//                    String color = getColorForSeverity(vuln.severity);
//                    writer.write(String.format("  \"%s\" [color=%s];\n", vuln.packageName, color));
//                    processedDeps.add(vuln.packageName);
//                }
//            }
//
//            writer.write("}\n");
//        }
//    }
//
//    private String getColorForSeverity(String severity) {
//        switch (severity.toUpperCase()) {
//            case "CRITICAL":
//                return "red";
//            case "HIGH":
//                return "orange";
//            case "MEDIUM":
//                return "yellow";
//            case "LOW":
//                return "green";
//            default:
//                return "gray";
//        }
//    }
//
//    private void generateTimelineReport(List<VulnerabilityInfo> vulnerabilities, String outputPath) throws IOException {
//        try (FileWriter writer = new FileWriter(outputPath.replace(".csv", "_timeline.md"))) {
//            writer.write("# Vulnerability Timeline Analysis\n\n");
//
//            // Group vulnerabilities by discovery date (if available)
//            Map<String, List<VulnerabilityInfo>> timelineMap = new TreeMap<>();
//
//            for (VulnerabilityInfo vuln : vulnerabilities) {
//                // You would need to add discovery date to VulnerabilityInfo
//                String discoveryDate = vuln.getDiscoveryDate(); // Add this field
//                timelineMap.computeIfAbsent(discoveryDate, k -> new ArrayList<>()).add(vuln);
//            }
//
//            for (Map.Entry<String, List<VulnerabilityInfo>> entry : timelineMap.entrySet()) {
//                writer.write(String.format("## %s\n\n", entry.getKey()));
//                for (VulnerabilityInfo vuln : entry.getValue()) {
//                    writer.write(String.format("- [%s] %s - %s\n", vuln.severity, vuln.cve, vuln.packageName));
//                }
//                writer.write("\n");
//            }
//        }
//    }
//
////    private void storeScanResults(List<VulnerabilityInfo> vulnerabilities) throws IOException {
////        // Store scan results for trend analysis
////        JSONObject scanResult = new JSONObject();
////        scanResult.put("date", new java.util.Date().toString());
////        scanResult.put("vulnerabilities", new JSONArray(vulnerabilities));
////        try (FileWriter writer = new FileWriter(previousScans, true)) {
////            writer.write(scanResult.toString() + "\n");
////        }
////    }
//}
//
////    private void generateTrendAnalysis(List<VulnerabilityInfo> currentVulnerabilities, String outputPath) throws IOException {
////        try (FileWriter writer = new FileWriter(outputPath.replace(".csv", "_trends.md"))) {
////            writer.write("# Vulnerability Trend Analysis\n\n");
////
////            // Read previous scans and compare
////            List<JSONObject> previousResults = readPreviousScans();
////
////            // Calculate trends
////            int newVulnerabilities = calculateNewVulnerabilities(previousResults, currentVulnerabilities);
////            int resolvedVulnerabilities = calculateResolvedVulnerabilities(previousResults, currentVulnerabilities);
////
////            writer.write(String.format("New Vulnerabilities: %d\n", newVulnerabilities));
////            writer.write(String.format("Resolved Vulnerabilities: %d\n", resolvedVulnerabilities));
